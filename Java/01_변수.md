## 변수의 타입
- 기본형 변수는 실제 값(data)을 저장
- 참조형 변수는 주소를 값으로 저장
- 기본형(primitive type): 논리형(boolean), 문자형(char), 정수형(byte, short, int, long), 실수형(float, double)
- 참조형(reference type): 객체의 주소 저장
* 참조형 변수는 null 또는 객체의 주소를 값으로 갖는다(4byte). 단, JVM이 32bit가 아니라 64bit라면 참조형 변수의 크기는 8byte가 된다.
   
### 기본형
- 문자형인 char는 문자를 내부적으로 정수(유니코드)로 저장->정수형 또는 실수형과 연산도 가능
- boolean(1byte)
- char(2byte)
- byte(1byte) / short(2byte) / int(4byte) / long(8byte)
- float(4byte) /double(8byte)
- int타입의 변수는 대략 10자리 수(약 20억)의 갑을 저장할 수 있다
- float 정밀도: 7자리 / double 정밀도: 15자리
   
### 상수와 리터럴
- 리터럴(literal): 그 자체로 값을 의미하는 것
- 리터럴 타입과 접미사: L, f, d(double은 생략 가능)
- 16진수를 표시하기 위해 리터럴 앞에 접두사 '0x' 또는 '0X'를, 8진수의 경우에는 '0'을 붙인다
- 정수형 리터럴의 중간에 구분자'_'를 넣을 수 있게 되어서 큰 숫자를 편하게 읽을 수 있게 되었다
- 리터럴에 소수점이나 10의 제곱을 나타내는 기호 E 또는 e, 그리고 접미사 f, F, D, d를 포함하고 있으면 실수형 리터럴로 간주
- 타입이 달라도 저장범위가 넓은 타입에 좁은 타입의 값을 저장하는 것은 허용된다
- 덧셈 연산자(+)는 모두 숫자일 때는 두 수를 더하지만, 피연산자 중 어느 한 쪽이 String이면 나머지 한 쪽을 먼저 String으로 변환한 다음 두 String을 결합한다
   
### 형식화된 출력-printf()
- printf()는 '지시자(specifier)'를 통해 변수의 값을 여러 가지 형식으로 변환하여 출력하는 기능을 가지고 있다
- 줄바꿈을 하려면 지시자 '%n'을 따로 넣어줘야 한다
- 자주 사용되는 printf()의 지시자
  + %b: boolean형식으로 출력
  + %d: decimal 정수
  + %o: octal 정수
  + %x,%X: 16진 정수
  + %f: floating-point
  + %e, %E: 지수 표현식
  + %c: character
  + %s: string
  + '0'과 '-'의 역할
    ```
      System.out.printf("finger = [%5d]%n", finger);  // finger = [   10]
      System.out.printf("finger = [%-5d]%n", finger);  // finger = [10   ]
      System.out.printf("finger = [%05d]%n", finger);  // finger = [00010]
    ``` 
  + 지시자 '%x'와  '%o'에 '#'를 사용하면 접두사 '0x'와 '0'이 각각 붙는다. 그리고 '%X'는 16진수에 사용되는 접두사와 영문자를 대문자로 출력한다.
  + 2진수 정수 지시자는 없기 때문에, 정수를 2진 문자열로 변환해주는 'Integer.toBinaryString(int i)'를 사용해야 한다
  + '%f'는 기본적으로 소수점 아래 6자리까지만 출력하기 때문에 소수점 아래 7자리에 반올림한다. 소수점도 한자리를 차지하며, 소수점 아래의 빈자리는 0으로 채우고 정수의 빈자리는 공백으로 채워서 전체 자리수를 맞춘다.
  + '%s'
    ```
    System.out.printf("[%s]%n", url); // 문자열의 길이만큼 출력공간을 확보
    System.out.printf("[%20s]%n", url); // 최소 20글자 출력공간 확보(우측정렬)
    System.out.printf("[%-20s]%n", url); // 최소 20글자 출력공간 확보(좌측정렬)
    System.out.printf("[%.8s]%n", url); // 왼쪽에서 8글자만 출력
    ```
       
        
## 진법
### 비트와 바이트
'워드(word)'는 'CPU가 한 번에 처리할 수 있는 데이터의 크기'. 32비트 CPU에서 1워드는 32비트(4바이트)이고, 64비트 CPU에서는 64비트(8바이트)이다.
### 실수의 진법변환
- 10진 소수점수를 2진 소수점수로 변환하는 방법
  1. 10진 소수에 2를 곱한다
     0.625*2=1.25
  2. 위의 결과에서 소수부만 가져다가 다시 2를 곱한다
     0.25*2=0.5
  3. 1과 2의 과정을 소수부가 0이 될 때까지 반복한다
  4. 위의 결과에서 정수부만을 위에서 아래로 순서대로 적고 '0.'을 앞에 붙이면 된다
     0.625*2=1.25
     0.25*2=0.5
     0.5*2=1.0
     => 0.625(10) = 0.101(2)
  * 정수부가 있는 소수점수는 정수부 123과 소수점부 0.456을 따로 변환한 다음에 더하면 된다
 ### 음수의 2진 표현 - 2의 보수법
 - 'n의 보수'는 더했을 때 n이 되는 수
 - '2의 보수 관계'에 있는 두 2진수를 더하면 (자리올림이 발생하고)0이 된다
 - 음수의 2진 표현을 구하는 방법
   1. 음수의 절대값을 2진수로 변환한다
   2. 1에서 구한 2진수의 1을 0으로 0은 1로 바꾼다(1의 보수 구하기)
   3. 2의 결과에 1을 더한다(2의 보수 구하기, 1의 보수+1)
    
 ## 기본형(primitive type)
 ### 논리형 - boolean
 자바에서는 데이터를 다루는 최소단위가 byte이기 때문에, boolean의 크기가 1byte
 ### 문자형 - char
 - 특수문자를 표현하는 방법
   + tab: \t
   + backspace: \b
   + form feed: \f
   + new line: \n
   + carriage return: \r
   + 역슬래쉬: \\
   + 작은따옴표: \'
   + 큰따옴표: \"
   + 유니코드(16진수)문자: \u유니코드(ex: '\u0041')
 - 유니코드   
   모든 문자의 크기가 동일한 UTF-16이 문자를 다루기는 편리하지만, 1byte로 표현할 수 있는 영어와 숫자가 2byte로 표현된다. UTF-8에서 영문과 숫자는 1byte 그리고 한글은 3byte로 표현되기 때문에 문서의 크기가 작지만 문자의 크기가 가변적이므로 다루기 어렵다.
### 정수형 - byte, short, int, long
- 정수형의 선택기준
  JVM의 피연산자 스택(operand stack)이 피연산자를 4byte단위로 저장하기 때문에 크기가 4byte보다 작은 자료형(byte, short)의 값을 계산할 때는 4byte로 변환하여 연산이 수행된다
  * long타입의 범위를 벗어나는 값을 다룰 때는, 실수형 타입이나 BigInteger클래스를 사용하면 된다
- 부호있는 정수의 오버플로우
  부호있는 정수는 부호비트가 0에서 1이 될 때 오버플로우가 발생한다
### 실수형 - float, double
- 정수형과 달리 실수형에서는 오버플로우가 발생하면 변수의 값은 무한대가 된다
- 정수형에는 없는 '언더플로우(underflow)'가 있는데, '언더플로우'는 실수형으로 표현할 수 없는 아주 작은 값, 즉 양의 최소값보다 작은 값이 되는 경우를 말한다. 이 때 변수의 값은 0이 된다.
- int타입은 '부호와 값', 두 부분으로 이루어져있지만, float타입과 같은 실수형은 '부호(S), 지수(E), 가수(M)', 세 부분으로 이루어져 있다. 즉, '2의 제곱을 곱한 형태(+-M*2^E)'로 저장하기 때문에 이렇게 큰 범위의 값을 저장하는 것이 가능하다. 그러나 정수형과 달리 실수형은 오차가 발생할 수 있다는 단점이 있다.
- '%f'는 기본적으로 소수점 이하 6자리까지만 출력하므로, 7번째 자리에서 반올림된다
- 실수형 값은 부동소수점수(floating-point)의 형태로 저장된다. 부동소수점수는 실수를 '+-M*2^E'와 같은 형태로 표현하는 것을 말하며, 부동소수점수는 부호, 지수, 가수, 모두 세 부분으로 이루어져있다.
- float: S(1)+E(8)+M(23)=32(4byte) / double: S(1)+E(11)+M(52)=64(8byte)
  + 부호(Sign bit)
    정수형과 달리 '2의 보수법'을 사용하지 않기 때문에 양의 실수를 음의 실수로 바꾸려면 그저 부호비트만 0에서 1로 변경하면 된다
  + 지수(Exponent)
    float의 경우, '-127~128'의 값이 저장된다. 이 중에서 -127과 128은 NaN이나 POSITIVE_INFINITY, NEGATIVE_INFINITY와 같이 특별한 값의 표현을 위해 예약되어 있다.
  + 가수(Mantissa)
    float의 정밀도는 7자리(소수점이하 6자리)
    
## 형변환
### 정수형간의 형변환
큰 타입에서 작은 타입으로의 변환하는 경우는 크기의 차이만큼 잘려나간다. 그래서 경우에 따라 '값 손실'이 발생할 수 있다.
- 자동 형변환
  서로 다른 두 타입간의 덧셈에서는 두 타입 중 표현범위가 더 넓은 타입으로 형변환하여 타입을 일치시킨 다음에 연산을 수행한다
  + 기본형의 자동 형변환이 가능한 방향   
    byte -> short -> int -> long -> float -> double   
    char -> int -> long -> float -> double
    
    
