## 연산자(operator)
연산자는 피연산자로 연산을 수행하고 나면 항상 결과값을 반환한다
### 연산자의 우선순위와 결합규칙
- 단항 연산자 : <- : ++ -- + - ~ ! (type) : 우선순위 높음
- 산술 연산자 : -> : * / %
- 산술 연산자 : -> : + - 
- 산술 연산자 : -> : << >>
- 비교 연산자 : -> : < > <= >= instanceof
- 비교 연산자 : -> : == !=
- 논리 연산자 : -> : &
- 논리 연산자 : -> : ^
- 논리 연산자 : -> : |
- 논리 연산자 : -> : &&
- 논리 연산자 : -> : ||
- 삼항 연산자 : -> : ?:
- 대입 연산자 : <- : = += -= *= /= %=
- 대입 연산자 : <- : <<= >>= &= ^= !=
### 산술 변환
- 작은 타입에서 큰 타입으로 형변환하는 경우, 자동적으로 형변환되므로 형변환 연산자를 생략할 수 있다
- 일반 산술 변환은 이항 연산에서만 아니라 단항 연산에서도 일어난다
* 피연산자의 타입이 int보다 작은 타입이면 int로 변환된다
* 모든 연산에서 '산술 변환'이 일어나지만, 쉬프트 연산자(<<, >>), 증감 연산자(++, --)는 예외이다
   
## 단항 연산자
### 증감 연산자 ++ --
- 식에 두번 이상 포함된 변수에 증감연산자를 사용하는 것은 피해야 한다
   
## 산술 연산자
### 사칙 연산자 +-*/
* 유니코드에서 문자에서 '0'을 빼주면 숫자로 변환된다
* 상수 또는 리터럴 간의 연산은 실행 과정동안 변하는 값이 아니기 때문에, 컴파일 시에 컴파일러가 계산해서 그 결과로 대체한다
* pi의 값을 소수점 셋째자리까지만 빼내는 방법: (int) (pi*1000) / 1000f;
* pi의 값을 소수점 넷째자리에서 반올림하는 방법
  - (int) (pi*1000+0.5) / 1000.0
  - Math.round(pi*1000) / 1000.0
   
## 비교 연산자
### 등가비교 연산자 == !=
대소비교 연산자와는 달리, 등가비교 연산자는 기본형은 물론 참조형, 즉 모든 자료형에 사용할 수 있다. 비교 연산자도 이항 연산자이므로 연산을 수행하기 전에 형변환을 통해 두 피연산자의 타입을 같게 맞춘 다음 피연산자를 비교한다. 두 문자열을 비교할 때는, 비교 연산자 '=='대신 equals()라는 메서드를 사용해야 한다.
   
## 논리 연산자
### 논리 연산자 && || !
- 효율적인 연산
  OR연산 '||'의 경우, 좌측 피연산자가 true이면, 우측 피연산자의 값은 평가하지 않는다. AND연산 '&&'의 경우도 좌측 피연산자가 false이면, 우측 피연산자는 평가하지 않는다.
### 비트 연산자 & \ ^ ~ << >>
비트 연산자는 피연산자를 비트단위로 논리 연산한다. 비트연산에서도 피연산자의 타입을 일치시키는 '산술 변환'이 일어날 수 있다.
- 비트 전환 연산자 ~ : 이 연산자는 피연산자를 2진수로 표현했을 때, 0은 1로, 1은 0으로 바꾼다
- 쉬프트 연산자 << >>
  + 자리이동으로 저장범위를 벗어난 값들은 버려지고 빈자리는 0으로 채워진다
  + '<<'연산자의 경우, 피연산자의 부호에 상관없이 각 자리를 왼쪽으로 이동시키며 빈칸을 0으로만 채우면 되지만, '>>'연산자는 오른쪽으로 이동시키기 때문에 부호있는 정수는 부호를 유지하기 위해 왼쪽 피연산자가 음수인 경우 빈자리를 1로 채운다. 물론 양수일 때는 0으로 채운다.
  + 쉬프트 연산자의 좌측 피연산자는 산술변환이 적용되지만, 우측 피연산자에는 산술변환이 적용되지 않는다
  + x << n은 x*2^n의 결과와 같다
  + x >> n은 x/2^n의 결과와 같다
  + '<<' 연산자를 사용하는 것이 '/' 또는 '*'연산자를 사용하는 것보다 더 빠르다

## 그 외의 연산자
### 조건 연산자 ?:
- 조건식 ? 식1 : 식2
- 조건 연산자의 식1과 식2, 이 두 피연산자의 타입이 다른 경우, 이항 연산자처럼 산술 변환이 발생한다
### 대입 연산자 = op=
대입연산자의 rvalue는 변수뿐만 아니라 식이나 상수 등이 모두 가능한 반면, lvalue는 반드시 변수처럼 값을 변경할 수 있는 것이어야 한다
