## 객체지향언어
### 객체지향언어
1. 코드의 재사용성이 높다
2. 코드의 관리가 용이하다 : 코드간의 관계를 이용해서 적은 노력으로 쉽게 코드를 변경할 수 있다
3. 신뢰성이 높은 프로그래밍을 가능하게 한다 : 제어자와 메서드를 이용해서 데이터를 보호하고 올바른 값을 유지하도록 하며, 코드의 중복을 제거하여 코드의 불일치로 인한 오동작을 방지할 수 있다
   
## 클래스와 객체
### 클래스와 객체의 정의와 용도
- 클래스의 정의 : 클래스란 객체를 정의해 놓은 것이다
- 클래스의 용도 : 클래스는 객체를 생성하는데 사용된다
- 객체의 정의 : 실제로 존재하는 것. 사물 또는 개념
   
### 객체와 인스턴스
클래스 ------(인스턴스화)-----> 인스턴스(객체)   
   
### 객체의 구성요소 - 속성과 기능
- 속성(property) : 멤버변수(member variable), 특성(attribute), 필드(field), 상태(state)
- 기능(function) : 메서드(method), 함수(function), 행위(behavior)
   
### 인스턴스의 생성과 사용
```
클래스명 변수명; // 클래스의 객체를 참조하기 위한 참조변수를 선언
변수명 = new 클래스명(); // 클래스의 객체를 생성 후, 객체의 주소를 참조변수에 저장
```
   
- Tv t;   
메모리에 참조변수 t를 위한 공간이 마련된다. 아직 인스턴스가 생성되지 않았으므로 참조변수로 아무것도 할 수 없다.
- t = new Tv();   
연산자 new에 의해 Tv클래스의 인스턴스가 메모리의 빈 공간에 생성된다. 멤버변수는 각 자료형에 해당하는 기본값으로 초기화 된다. 그 다음에는 대입연산자(=)에 의해서 생성된 객체의 주소값이 참조변수 t에 저장된다.   
   
+ Tv t1 = new Tv();
  Tv t2 = new Tv();
+ t2 = t1;  // t1이 저장하고 있는 값(주소)을 t2에 저장한다
* 자신을 참조하고 있는 참조변수가 하나도 없는 인스턴스는 더 이상 사용되어질 수 없으므로 '가비지 컬렉터(Garbage Collector)'에 의해서 자동적으로 메모리에서 제거된다
   
### 클래스의 또 다른 정의
- 구조체 : 서로 관련된 여러 데이터를 종류에 관계없이 하나의 집합으로 저장할 수 있는 공간
- 클래스 : 데이터와 함수의 결합(구조체 + 함수)
* 자바에서 문자열을 단순히 문자의 배열로 정의하지 않고 클래스로 정의한 이유는 문자열과 문자열을 다루는데 필요한 함수들을 함께 묶기 위해서이다
   
   
## 변수와 메서드
### 선언위치에 따른 변수의 종류
- 클래스변수(class variable) : 클래스 영역에 선언 / 클래스가 메모리에 올라갈 때 생성
- 인스턴스변수(instance variable) : 클래스 영역에 선언 / 인스턴스가 생성되었을 때 생성
- 지역변수(local variable) : 클래스 영역 이외의 영역(메서드, 생성자, 초기화 블럭 내부) / 변수 선언문이 수행되었을 때 생성
   
+ 클래스 변수
클래스변수는 모든 인스턴스가 공통된 저장공간(변수)를 공유하게 된다. 인스턴스변수와 달리 인스턴스를 생성하지 않고도 언제라도 바로 사용할 수 있으며, '클래스이름.클래스변수'와 같은 형식으로 사용한다. 클래스가 메모리에 로딩될 때 생성되어 프로그램이 종료될 때 까지 유지되며, public을 앞에 붙이면 같은 프로그램 내에서 어디서나 접근할 수 있는 '전역변수(global variable)'의 성격을 갖는다.
   
### 메서드
- 메서드를 사용하는 이유
1. 높은 재사용성
2. 중복된 코드의 제거
3. 프로그램의 구조화
   
### JVM의 메모리 구조
응용프로그램이 실행되면, JVM은 시스템으로부터 프로그램을 수행하는데 필요한 메모리를 할당받고 JVM은 이 메모리를 용도에 따라 여러 영역으로 나누어 관리한다
1. 메서드 영역 : 프로그램 실행 중 어떤 클래스가 사용되면, JVM은 해당 클래스의 클래스파일(*.class)을 읽어서 분석하여 클래스에 대한 정보(클래스 데이터)를 이곳에 저장한다. 이 때, 그 클래스의 클래스변수도 이 영역에 함께 생성된다.
2. 힙(heap) : 인스턴스가 생성되는 공간. 프로그램 실행 중 생성되는 인스턴스는 모두 이곳에 생성된다. 즉, 인스턴스변수들이 생성되는 공간이다.
3. 호출스택(call stack/execution stack) : 호출스택은 메서드의 작업에 필요한 메모리 공간을 제공한다. 메서드가 호출되면, 호출스택에 호출된 메서드를 위한 메모리가 할당되며, 이 메모리는 메서드가 작업을 수행하는 동안 지역변수(매개변수 포함)들과 연산의 중간결과 등을 저장하는데 사용된다.
   
### 기본형 매개변수와 참조형 매개변수
매개변수의 타입이 기본형(primitive type)일 때는 기본형 값이 복사되겠지만, 참조형(reference type)이면 인스턴스의 주소가 복사된다. 메서드의 매개변수를 기본형으로 선언하면 단순히 저장된 값만 얻지만, 참조형으로 선언하면 값이 저장된 곳의 주소를 알 수 있기 때문에 값을 읽어 오는 것은 물론 값을 변경하는 것도 가능하다.
   
### 클래스 메서드와 인스턴스 메서드
인스턴스 메서드는 인스턴스 변수와 관련된 작업을 하는, 즉 메서드의 작업을 수행하는데 인스턴스 변수를 필요로 하는 메서드이다. 인스턴스와 관계없는(인스턴스 변수나 인스턴스 메서드를 사용하지 않는) 메서드를 클래스 메서드(static 메서드)로 정의한다.   
   
- 클래스 메서드는 인스턴스 변수를 사용할 수 없다. 인스턴스변수는 인스턴스가 반드시 존재해야만 사용할 수 있는데, 클래스메서드는 인스턴스 생성 없이 호출가능하므로 클래스 메서드가 호출되었을 때 인스턴스가 존재하지 않을 수도 있다. 그래서 클래스 메서드에서 인스턴스변수의 사용을 금지한다. 반면에 인스턴스변수나 인스턴스메서드에서는 static이 붙은 멤버들을 사용하는 것이 언제나 가능하다. 인스턴스 변수가 존재한다는 것은 static변수가 이미 메모리에 존재한다는 것을 의미하기 때문이다.
- 메서드 내에서 인스턴스 변수를 사용하지 않는다면, static을 붙이는 것을 고려한다. static을 붙이면 메서드 호출시간이 짧아지므로 성능이 향상된다. static을 안 붙인 메서드(인스턴스메서드)는 실행 시 호출되어야할 메서드를 찾는 과정이 추가적으로 필요하기 때문에 시간이 더 걸린다.
   
### 클래스 멤버와 인스턴스 멤버간의 참조와 호출
같은 클래스에 속한 멤버들 간에는 별도의 인스턴스를 생성하지 않고도 서로 참조 또는 호출이 가능하다. 단, 클래스멤버가 인스턴스 멤버를 참조 또는 호출하고자 하는 경우에는 인스턴스를 생성해야 한다.
   
   
## 오버로딩(overloading)
### 오버로딩이란?
한 클래스 내에 같은 이름의 메서드를 여러 개 정의하는 것을 '메서드 오버로딩', '오버로딩'이라 한다
   
### 오버로딩의 조건
1. 메서드 이름이 같아야 한다
2. 매개변수의 개수 또는 타입이 달라야 한다
반환 타입은 오버로딩을 구현하는데 아무런 영향을 주지 못한다
   
### 오버로딩의 예
- println
- long add(int a, long b) { return a+b; }   
  long add(long a, int b) { return a+b; }   
  두 메서드 모두 int형과 long형 매개변수가 하나씩 선언되어 있지만, 서로 순서가 다른 경우이다. 이 경우에는 호출 시 매개변수의 값에 의해 호출될 메서드가 구분될 수 있으므로 중복된 메서드 정의가 아닌, 오버로딩으로 간주한다. 단, 이 경우에는 add(3, 3)과 같이 호출할 수 없다.
   
### 오버로딩의 장점
메서드의 이름만 보고도 '이 메서드들은 이름이 같으니, 같은 기능을 하겠구나,'라고 쉽게 예측할 수 있게 된다. 메서드의 이름을 절약할 수도 있다.
   
### 가변인자(varargs)와 오버로딩
기존에는 메서드의 매개변수 개수가 고정적이었으나 JDK1.5부터 동적으로 지정해줄 수 있게 되었으며, 이 기능을 '가변인자(variable arguments)'라고 한다. 가변인자는 '타입...변수명'과 같은 형식으로 선언한다. 가변인자 외에도 매개변수가 더 있다면, 가변인자를 매개변수 중에서 제일 마지막에 선언해야 한다.
- String concatenate(String... str) { ... }   
  이 메서드를 호출할 때는 인자의 개수를 가변적으로 할 수 있다. 심지어는 인자가 아예 없어도 되고 배열도 인자가 될 수 있다. ㅏ변인자는 내부적으로 배열을 이용하는데, 가변인자가 선언된 메서드를 호출할 때마다 배열이 새로 생성된다. 이런 비효율이 숨어있으므로 꼭 필요한 경우에만 가변인자를 사용하자.
- System.out.println(concatenate("-", new String[] {"100", "200", "300"}));   
  위와 같이 쓸 수 있다. 하지만 아래와 같은 문장은 허용되지 않는다.   
  System.out.println(concatenate("-", {"100", "200", "300"}));   
- 가변인자를 선언한 메서드를 오버로딩하면, 메서드를 호출했을 때 구별되지 못하는 경우가 발생하기 쉽기 때문에 주의해야 한다.
   
   
## 생성자(Constructor)
### 생성자란?
- 생성자는 리턴 값이 없다
- 연산자 new가 인스턴스를 생성하는 것이지 생성자가 인스턴스를 생성하는 것이 아니다. 생성자는 단순히 인스턴스변수들의 초기화에 사용되는 조금 특별한 메서드일 뿐이다
   
### 생성자에서 다른 생성자 호출하기 - this(), this
생성자 간에도 서로 호출이 가능하다
- 생성자의 이름으로 클래스이름 대신 this를 사용한다
- 한 생성자에서 다른 생성자를 호출할 때는 반드시 첫 줄에서만 호출이 가능하다
- 생성자에서 다른 생성자를 첫 줄에서만 호출이 가능하도록 한 이유는 생성자 내에서 초기화 작업도주에 다른 생성자를 호출하게 되면, 호출된 다른 생성자 내에서도 멤버변수들의 값을 초기화를 한 것이므로 다른 생성자를 호출하기 이전의 초기화 작업이 무의미해질 수 이씨 때문이다
- 'this'를 사용할 수 있는 것은 인스턴스멤버뿐이다. static메서드는 인스턴스를 생성하지 않고도 호출될 수 있으므로 static메서드가 호출된 시점에 인스턴스가 존재하지 않을 수도 있기 때문이다
- this는 '참조 변수'이고, this()는 '생성자'이다
   
   
## 변수의 초기화
### 각 타입의 기본값
- boolean : false
- char : '\u0000'
- byte, short, int : 0
- long : 0L
- float : 0.0f
- double : 0.0d 또는 0.0
- 참조형 변수 : null
   
### 명시적 초기화(explicit initialization)
변수를 선언과 동시에 초기화하는 것
   
### 초기화 블럭(initialization block)
- 클래스 초기화 블럭 : 클래스변수의 복잡한 초기화에 사용
- 인스턴스 초기화 블럭 : 인스턴스변수의 복잡한 초기화에 사용
   
```
class InitBlock {
  static { /* 클래스 초기화블럭 입니다. */ }
  { /* 인스턴스 초기화블럭 입니다. */ }
  // ...
}
```
클래스 초기화 블럭은 클래스가 메모리에 처음 로딩될 때 한번만 수행되며, 인스턴스 초기화 블럭은 생성자와 같이 인스턴스를 생성할 때마다 수행된다. 생성자보다 인스턴스 초기화 블럭이 먼저 수행된다. 배열이나 예외처리가 필요한 초기화에서는 명시적 초기화만으로는 복잡한 초기화 작업을 할 수 없다. 이런 경우에 추가적으로 클래스 초기화 블럭을 사용하도록 한다.
   
### 멤버변수의 초기화 시기와 순서
- 클래스변수의 초기화시점 : 클래스가 처음 로딩될 때 단 한번 초기화 된다
- 인스턴스변수의 초기화시점 : 인스턴스가 생성될 때마다 각 인스턴스별로 초기화가 이루어진다
- 클래스변수 기본값 초기화 -> 클래스변수 명시적초기화 -> 클래스변수 초기화 블럭 -> 인스턴스변수 기본값 초기화 -> 인스턴스변수 명시적 초기화 -> 인스턴스변수 초기화 블럭 -> 인스턴스변수 생성자 초기화
   

