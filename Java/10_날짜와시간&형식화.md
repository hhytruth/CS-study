## 형식화 클래스
### DecimalFormat
```
double number = 1234567.89;
DecimalFormat df = new DecimalFormat("#.#E0");
String result = df.format(number);
```
[DecimalFormat의 패턴에 사용되는 기호]   
|기호|의미|패턴|결과(1234567.89)|
|---|---|---|---|
|0|10진수(값이 없을 때는 0)|0 / 0.0 / 0000000000.0000|1234568 / 1234567.9 / 0001234567.8900|
|#|10진수|# / #.# / ##########.####|1234568 / 1234567.9 / 1234567.89 |
|.|소수점|#.#|1234567.9|
|-|음수부호|#.#- / -#.#|1234567.9- / -1234567.9|
|,|단위 구분자|#,###.## / #,####.##|1,234,567.89 / 123,4567.89|
|E|지수기호|#E0 / 0E0 / ##E0 / 00E0 / ####E0 / 0000E0 / #.#E0 / 0.0E0 /0.000000000E0 / 00.00000000E0 / 000.0000000E0 / #.#########E0 / ##.########E0 / ###.#######E0|.1E7 / 1E6 / 1.2E6 / 12E5 / 123.5E4 / 1235E3 / 1.2E6 / 1.2E6 / 1.234567890E6 / 12.34567890E5 / 123.4567890E5 / 1.23456789E6 / 1.23456789E6 / 1.23456789E6|
|;|패턴구분자|#,###,##+;#,###,##-|1,234,567,89+(양수일때) / 1,234,567,89-(음수일때)|
|%|퍼센트|#.#%|123456789%|
|\u2030|퍼밀(퍼센트 x 10)|#.#\u2030|1234567890‰|
|\u00A4|통화|\u00A4 #,###|₩ 1,234,568|
|'|escape문자|'#'#,### / ''#,###|#1,234,567 / '1,234,568|
parse메서드를 이용하면 기호와 문자가 포함된 문자열을 숫자로 쉽게 변환할 수 있다.(Integer.parseInt메서드는 콤마(,)가 포함된 문자열을 숫자로 변환하지 못한다.)   
Number클래스는 Integer, Double과 같은 숫자를 저장하는 래퍼 클래스의 조상이며, doubleValue()는 Number에 저장된 값을 double형의 값으로 변환하여 반환한다. 이 외에도 intValue(), floatValue()등의 메서드가 Number클래스에 정의되어 있다.   
   
### SimpleDateFormat
날짜를 출력하려고 할 때 SimpleDateFormat을 쓰면 편리하다
```
Date today = new Date();
SimpleDateFormat df = new SimpleDateFormat("yyyy-MM-dd");

//오늘 날짜를 yyyy-MM-dd형태로 변환하여 반환한다
String result = df.format(today);
```
SimpleDateFormat의 parse(String source)는 문자열source을 날짜Date인스턴스로 변환해준다   
   
### ChoiceFormat
ChoiceFormat은 특정 범위에 속하는 값을 문자열로 변환해준다. 연속적 또는 불연속적인 범위의 값들을 처리하는 데 있어서 ChoiceFormat을 잘 사용하면 복잡하게 처리될 수밖에 없었던 코드를 간단하고 직관적으로 만들 수 있다.
```
double[] limits = {60, 70, 80, 90}; // 낮은 값부터 큰 값의 순서로 적어야한다
//limits, grades간의 순서와 개수를 맞추어야 한다
String[] grades = {"D", "C", "B", "A"};

int[] scores = {100, 95, 88, 70, 52, 60, 70};

ChoiceFormat form = new ChoiceFormat(limits, grades);

for(int i=0;i<scores.length;i++) {
  System.out.println(scores[i]+":" + form.format(scores[i]));
}
```
다음은 이전 예제를 패턴을 사용하도록 변경한 것이다. '#'은 경계값을 범위에 포함시키지만, '<'는 포함시키지 않는다.
```
String pattern = "60#D|70#C|80<B|90#A";
int[] scores = {91, 90, 80, 88, 70, 52, 60};

ChoiceFormat form = new ChoiceFormat(pattern);

for(int i=0;i<scores.length;i++) {
  System.out.printl(scores[i]+":"+form.format(scores[i]));
}
```
   
### MessageFormat
MessageFormat은 데이터를 정해진 양식에 맞게 출력할 수 있도록 도와준다
```
String msg = "Name: {0} \nTel: {1} \nAge:{2} \nBirthday:{3}";

Object[] arguments = {"이자바", "0-123-1234", "27", "07-09" };

String result = MessageFormat.format(msg, arguments);
System.out.println(result);
```
   
   
## java.time패키지
java.time패키지에 속한 클래스들의 가장 큰 특징은 '불변(immutable)'이라는 것이다. 그래서 날짜나 시간을 변경하는 메서드들은 기존의 객체를 변경하는 대신 항상 변경된 새로운 객체를 반환한다. -> 쓰레드에 안전(thread-safe)   
### java.time패키지의 핵심 클래스
* 날짜와 시간을 초단위로 표현한 값을 타임스탬프라고 부른다
* 날짜와 시간에서 특정 필드의 값만을 얻을 때는 get()이나, get으로 시작하는 이름의 메서드를 이용한다. 그리고 특정 날짜와 시간에서 지정된 단위의 값을 더하거나 뺄 때는 plus() 또는 minus()에 값과 함께 열거형 ChronoUnit을 사용한다.
[객체 생성하기]   
now()는 현재 날짜와 시간을 저장하는 객체를 생성한다. of()는 단순히 해당 필드의 값을 순서대로 지정해주기만 하면 된다.   
   
### LocalDate와 LocalTime
LocalDate와 LocalTime은 java.time패키지의 가장 기본이 되는 클래스이다
* 날짜와 시간에서 특정 필드 값을 변경하려면, with로 시작하는 메서드를 사용하면 된다. 이 외에도 특정 필드에 값을 더하거나 빼는 plus()와 minus()가 있다.
* LocalTime의 truncatedTo()는 지정된 것보다 작은 단위의 필드를 0으로 만든다
* LocalDate와
* 
