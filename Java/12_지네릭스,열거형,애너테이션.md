## 지네릭스(Generics)
지네릭스는 JDK1.5에서 처음 도입되었다.   
   
### 지네릭스란?
지네릭스는 다양한 타입의 객체들을 다루는 메서드나 컬렉션 클래스에 컴파일 시의 타입 체크(compile-time type check)를 해주는 기능이다.   
   
- 지네릭스의 장점
  + 타입 안정성을 제공한다
  + 타입체크와 형변환을 생략할 수 있으므로 코드가 간결해진다
   
```
class Box<T> { // 지네릭 타입 T를 선언
  T item;
  void setItem(T item) { this.item = item; }
  T getItem() { return item; }
}
```
Box<T>에서 T를 '타입 변수(type variable)'라고 하며, "Type"의 첫 글자에서 따온 것이다. T가 아닌 다른 것을 사용해도 된다. 객체를 생성할 때는 다음과 같이 참조변수와 생성자에 타입 T 대신에 사용될 실제 타입을 지정해주어야 한다.
```
Box<String> b = new Box<String>();  // 타입 T 대신, 실제 타입을 지정
b.setItem(new Object());  // 에러. String 이외의 타입은 지정 불가
b.setItem("ABC"); // OK. String 타입이므로 가능
String item = ~~(String)~~ b.getItem(); // 형변환이 필요없음
```
컴파일 후에 Box<String>과 Box<Integer>는 이들의 '원시 타입'인 Box로 바뀐다. 즉, 지네릭 타입이 제거된다.   
   
[지네릭스의 제한]   
모든 객체에 대해 동일하게 동작해야하는 static 멤버에 타입 변수 T를 사용할 수 없다. T는 인스턴스 변수로 간주되기 때문이다.
```
class Box<T> {
  static T item;  // 에러
  static int compare(T t1, T t2) { ... }  // 에러
  ...
}
```
지네릭 타입의 배열을 생성하는 것도 허용되지 않는다. 지네릭 배열 타입의 참조변수를 선언하는 것은 가능하지만, 'new T[10]'과 같이 배열을 생성하는 것은 안 된다. 지네릭 배열을 생성할 수 없는 것은 new 연산자 때문인데, 이 연산자는 컴파일 시점에 타입 T가 뭔지 정확히 알아야 한다. instanceof연산자도 new연산자와 같은 이유로 T를 피연산자로 사용할 수 없다. 꼭 지네릭 배열을 생성해야할 필요가 있을 때는, new 연산자 대신 'Reflection API'의 newInstance()와 같이 동적으로 객체를 생성하는 메서드로 배열을 생성하거나, Object 배열을 생성해서 복사한 다음에 'T[]'로 형변환하는 방법 등을 사용한다.   
    
### 지네릭 클래스의 객체 생성과 사용
Box<T>의 객체를 생성할 때는 참조변수와 생성자에 대입된 타입(매개변수화된 타입)이 일치해야 한다.   
두 타입이 상속관계에 있어도 마찬가지이다.
```
Box<Fruit> appleBox = new Box<Apple>(); // 에러. 대입된 타입이 다르다.
```
단, 두 지네릭 클래스의 타입이 상속관계에 있고, 대입된 타입이 같은 것은 괜찮다. FruitBox는 Box의 자손이라고 가정하자.
```
Box<Apple> appleBox = new FruitBox<Apple>();  // OK. 다형성
```
JDK1.7부터는 추정이 가능한 경우 타입을 생략할 수 있게 되었다.
```
Box<Apple> appleBox = new Box<Apple>();
Box<Apple> appleBox = new Box<>();  // OK. JDK1.7부터 생략 가능
```
그러나 타입 T가 'Fruit'인 경우, 'void add(Fruit item)'가 되므로 Fruit의 자손들은 이 메서드의 매개변수가 될 수 있다. Apple이 Fruit의 자손이라고 가정하였다.
```
Box<Fruit> fruitBox = new Box<Fruit>();
fruitBox.add(new Fruit());   // OK
fruitBox.add(new Apple());  // OK. void add(Fruit item)
```
   
### 제한된 지네릭 클래스
지네릭 타입에 'extends'를 사용하면, 특정 타입의 자손들만 대입할 수 있게 제한할 수 있다.
```
class FruitBox<T extends Fruit> { // Fruit의 자손만 타입으로 지정 가능
  ArrayList<T> list = new ArrayList<T>();
  ...
}
```
만일 클래스가 아니라 인터페이스를 구현해야 한다는 제약이 필요하다면, 이 때도 'extends'를 사용한다. 'implements'를 사용하지 않는다는 점에 주의하자. 클래스 Fruit의 자손이면서 Eatable 인터페이스도 구현해야 한다면 '&'기호로 연결한다.   
    
### 와일드 카드
매개변수에 과일박스를 대입하면 주스를 만들어서 반환하는 Juicer라는 클래스가 있고, 이 클래스에는 과일을 주스로 만들어서 반환하는 makeJuice()라는 static메서드가 다음과 같이 정의되어 있다고 가정하자.
```
class Juicer {
  static Juice makeJuice(FruitBox<Fruit> box) { // <Fruit>으로 지정
    String tmp = "";
    for(Fruit f : box.getList()) tmp += f + " ";
    return new Juice(tmp);
  }
}
```
Juicer클래스는 지네릭 클래스가 아닌데다, 지네릭 클래스라고 해도 static메서드에는 타입 매개변수 T를 매개변수에 사용할 수 없으므로 아예 지네릭스를 적용하지 안던가, 위와 같이 타입 매개변수 대신, 특정 타입을 지정해줘야 한다. 지네릭 타입을 'FruitBox<Fruit>'로 고정해 놓으면, 'FruitBox<Apple>'타입의 개체는 makeJuice()의 매개변수가 될 수 없으므로, 여러 가지 타입의 매개변수를 갖는 makeJuice()를 만들 수 밖에 없다. 그러나 오버로딩을 하면, 컴파일 에러가 발생한다. 지네릭 타입이 다른 것만으로는 오버로딩이 성립하지 않기 때문이다. 이럴 대 사용하기 위해 고안된 것이 바로 '와일드 카드'이다.
- <? extends T> : 와일드 카드의 상한 제한. T와 그 자손들만 가능
- <? super T> : 와일드 카드의 하한 제한. T와 그 조상들만 가능
- <?> : 제한 없음. 모든 타입이 가능. <? extends Object>와 동일
   
* 지네릭 클래스와 달리 와일드 카드에는 '&'를 사용할 수 없다.
```
static Juice makeJuice(FruitBox<? extends Fruit> box) {
   String tmp = "";
   for(Fruit f : box.getList()) tmp += f + " ";
   return new Juice(tmp);
}
```
이제 이 메서드의 매개변수로 FruitBox<Fruit>뿐만 아니라, FruitBox<Apple>와 FruitBox<Grape>도 가능하게 된다.   
   
sort()는 원래 다음과 같이 정의되어 있다.
```
static <T> void sort(List<T> list, Comparator<? super T> c)
```
   
- Comparator<? super Apple> : Comparator<Apple>, Comparator<Fruit>, Comparator<Object>
- Comparator<? super Grape> : Comparator<Grape>, Comparator<Fruit>, Comparator<Object>
아래와 같이 FruitComp를 만들면, List<Apple>과 List<Grape>를 모두 정렬할 수 있다. 비교의 대상이 되는 weight는 Apple과 Grape의 조상인 Fruit에 정의되어 있기 때문에 가능하다.
```
class FruitComp implements Comparator<Fruit> {
   public int compare(Fruit t1, Fruit t2) {
      return t1.weight - t2.weight;
   }
}
...
// List<Apple>과 List<Grape>를 모두 Comparator<Fruit>으로 정렬
Collections.sort(appleBox.getList(), new FruitComp());
Collections.sort(grapeBox.getList(), new FruitComp());
```
이러한 장점 때문에 Comparator에는 항상 <? super T>가 습관적으로 따라 붙는다. 와일드 카드 때문에 Comparator를 어려워하는 경우가 많은데, 그럴 때는 그냥 와일드 카드를 무시하고 Comparator<T>라고 생삭하기 바란다.   
   
### 지네릭 메서드
메서드의 선언부에 지네릭 타입이 선언된 메서드를 지네릭 메서드라 한다.
```
static <T> void sort(List<T> list, Comparator<? super T> C)
```
지네릭 클래스에 정의된 타입 매개변수와 지네릭 메서드에 정의된 타입 매개변수는 전혀 별개의 것이다. 같은 타입 문자 T를 사용해도 같은 것이 아니라는 것에 주의해야 한다.
```
class FruitBox<T> {
   ...
   static <T> void sort(List<T> list, Comparator<? super T> c) {
      ...
   }
}
```
위의 코드에서 지네릭 클래스 FruitBox에 선언된 타입 매개변수 T와 지네릭 메서드 sort()에 선언된 타입 매개변수 T는 타입 문자만 같을 뿐 서로 다른 것이다. 앞서 설명한 것처럼, static멤버에는 타입 매개변수를 사용할 수 없지만, 이처럼 메서드에 지네릭 타입을 선언하고 사용하는 것은 가능하다.   
